1-7~10 스케쥴링

2023년 6월 28일 수요일
오후 8:31

	1. 워크로드 : 프로세스가 동작하는 일련의 행위
		- 프로세스 스케쥴링을 짜기 위해선 워크로드를 이해해야한다.

	2. 스케쥴링의 평가 항목
		- 반환시간 : Turnaround Time
			§ TturnAround = Tcomplition - Tarrival
		- 응답시간 : Reponse Time
			§ Tresponse = Tfirst complete - Tarrival
			§ 프로세스 공정성과 관련이 있음.



	3. 단일 피드백 스케쥴러 종류
		a. FIFO
			- 선입 선출 : 가장 간단하지만, Convoy Problem 이 발생할 수 있음.
				□ Convoy Problem : CPU 점유시간이 짧은 프로세스가 긴 프로세스가 끝날때 까지 하염없이 기다리는 비효율
				
		b. SJF (Shortest Job First) : 최단 작업 우선
			- 모든 프로세스가 동일한 시각에 동시에 도착한 경우 최적의 프로그램
			- 프로세스 중에서 CPU 점유시간이 짧은 프로세스가 나중에 도착한다면 여전히 Convoy Problem 이 발생함.
				□ 
		c. STCF (Shortest Time to complete First) : 최단 잔여시간 우선
			- 작업이 도중에 중단될 수 있는 기법을 추가함.
			- H/W의 Timer Interrupt 를 이용하여 프로세스가 도착할 때마다 최단 잔여시간을 계산하여 해당 프로세스부터 실행
				□ 
		d. RR (Round Robin) : 
			- 응답시간을 높이기 위한 기법.
			- 프로세스를 Time Slice (타임 슬라이스 or scheduling Quantum) 고려하여 Rotate 시켜가며 실행시키는 기법
			- 응답시간은 매우 좋지만 반환시간은 매우 최악인 알고리즘
			- 여기서 Time Slice는 H/W 의 timer Intrupt 의 배수가 되어야한다. (주의)
				□ Time Slice 와 성능과의 관계
					® Time Slice가 짧을수록 일반적으로 성능이 좋지만, Context Switch 의 비용보다는 길어야한다.
			-  RR 은 응답시간 때문에 프로세스가 공평하게 번갈아가며 실행되기 때문에 공정하다고 한다.
				□ 


	4. 입출력을 고려한 스케쥴러
		- 프로세스가 실행될 때 I/O 작업이 개시되면 해당 프로세스는 대기 (Blocked) 상태가 된다.
			- 대기 상태(Blocked) -> Ready(준비) 상태로 변화한다.
		- 해당 프로세스가 대기시간동안 중첩을 허용하여 다른프로세스를 실행하도록 하여 성능을 높인다.
		- 
		
		
	5. 위의 스케쥴러들은 모두 해당 프로세스가 얼마동안 CPU 점유를 유지하는지 미리 알고 실행되는 방식이다.
	현실은 이와 다르기 때문에 프로세스의 미래 동작을 예측함에 있어 과거의 프로세스 동작 이력을 반영하는 
	멀티레벨 피드백 큐 (Multilevel Feedback Queue) 를 도입하여 해결할 수 있다.

#2. 멀티레벨 피드백 스케쥴링 (Multilevel Feedback Scheduling Queue) : MLFQ
	<목표>
	- 긴 작업보다 짧은 작업은 가자 먼저 실행하여 반환시간을 줄인다. (SJF/STCF 비슷)
	- 동일한 우선순위를 가지는 작업은 Round Robin 방식으로 응답시간을 줄인다. (RR)
	<설계>
	- 우선순위가 다른 큐들을 가지고 있다.
	
	※ 보통, 대화형 프로세스는 쉘과 통신하는 방식으로 CPU 점유시간이 짧지만 자주 양보함
		반대로, 배치형 프로세스는 CPU를 집중적으로 사용함.

	2. MLFQ의 문제점!
		1. 기아상태 (Starvation) : 다수의 대화형 프로세스로 인한 배치형 프로세스가 CPU 사용을 못하는 상태
		2. 이기적인 점유 : 중간마다 잦은 I/O 를 활용하여 CPU Time Slicing 을 99%까지 극대화하게 사용한 후 교대로 사용하는 프로세스의 존재.
			Ø 해당 방식을 보통 "공격" 이라고 함.
		3. 프로세스 성질 변화 (배치형 <--> 대화형)

		Ø 1,3 번 문제점은 우선순위의 상향조정을 통해 해결할 수 있음. (아래 5번규칙)
			§ 모든 작업의 우선순위가 일정한 주기 (S) 가 지난 후 모두 최상위 큐에 간다면 해결될 수 있다.
			§ 그렇게되면, 프로세스가 대화형-->배치형으로 바뀌더라도 S 주기 후에 알아서 자동으로 판별될 수 있음.
		Ø 2번 이기적인 점유 문제를 해결하기 위해서 총 CPU 점유시간 을 도입하여 해결할 수 있다. (아래 4번 규칙)
			§ 프로세스 큐 마다 작업이 총 합쳐 최대한 사용할 수 있는 CPU 사용시간을 설정해놓고 사용한만큼 차감하여 
			다 사용했을 시 큐의 우선순위를 한 단계 강등시키는 방법
			§ 즉, 자기 이상의 몫의 CPU 시간을 사용할 수 없어 이기적인 점유 문제를 해결할 수 있다.

	3. MLFQ 구성 (규칙)
		1. 우선순위가 높은 큐에 속한 작업(프로세스)부터 CPU 점유
		2. 같은 우선순위를 가지는 큐 내부에서는 RR 스케쥴러를 이용하여 응답시간을 줄임.
		3. 작업이 시스템에 들어가면 최상위 큐에 배치됨.
		4. 작업이 지정한 단계(큐)에 할당된 CPU 시간을 모두 소진하면 우선순위가 내려감.
			Ø 보통 타임슬라이스는 우선순위가 높은 큐 일 수록 적은 시간으로 배치해두는게 효율적임. (대화형일 수록 짧은 Time Slice 시간)
				
			i. 주어진 작업 타임슬라이스 (Time Slice)를 모두 소모하면 현재 스케쥴링 큐 에서 한 단계씩 내려옴.
				
			ii. 주어진 작업 타임슬라이스를 소모하기 전에 CPU 작업이 끝난다면 (혹은 대기상태가된다면) 우선순위가 하락하지 않음.
				
				1) 해당 표를 통해, 대화형 방식인 회색 프로세스는 CPU 점유시간이 타임슬라이싱을 초과하지 않아 우선순위가 내려가지 않지만,
				배치형 프로세스인 검은색 프로세스는 CPU 타임 슬라이싱을 초과하여 한 단계씩 내려오고 있음.
		5. 일정 주기가 지나면 모든 작업을 최상위 큐로 이동시킴.



	4. 스케쥴러에게 힌트를 주기
		- 스케쥴러 자체로는 어떤 프로세스가 최선인 지 알기가 어려울 수 있다.
		그래서 우리는 사용자가 관리자에게 힌트를 전달할 수 있는 인터페이스를 제공하면 이러한 점에 도움이 된다.
			Ø 그리고 이러한 힌트(Hint) 들을 우리는 조언(Advice)라고 한다.
			Ø ex) 스케쥴러 (Nice) , 메모리 관리자 (madvise), 파일 시스템 (제공 정보에 기초한 선반입과 캐싱)
		- 일부 시스템에서 사용자가 우선순위를 변경할 수 있도록 하는 명령어 (nice) 를 제공하고 있다.
![image](https://github.com/20190511/StudyNote/assets/70988272/56e02265-190f-4e09-b923-b4b78f14162f)
